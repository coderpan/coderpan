<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Makefile实例解析]]></title>
      <url>http://coderpan.github.io/2015/11/18/Makefile%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>对于从事linux下C++开发的同学来说，makefile方面的知识是必不可少的。本文将选取一个实例来讲解makefile的运用方法,可能存在一些错误的地方，希望看到的同学批评指正，也借此抛砖引玉了：</p>
<p>一般来说，一个项目的后台服务部门至少包含一个公共的makefile文件，其中包含平台属性定义（比如32位/64位的判断等）、公共库目录（公共动态库、静态库的头文件目录、.o/.so文件生成目录等）、通用操作定义（all、clean、release等）…</p>
<blockquote>
<p class="text-info">本文适合对 Makefile 接触不多的同学阅读，其中涉及到的知识面比较窄，后面会慢慢完善！</p>
</blockquote>
<h2 id="项目公共Makefile">项目公共Makefile</h2><p>以下是我选取的项目公共makefile文件，讲述将以注释的形式穿插在代码中，过程中会顺带讲些与makefile相关的内容：</p>
<a id="more"></a>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strip函数显然是去空格，这句是获取主机CPU位数，用于编译参数 -m32（编译32位版本）、-m64（编译64位版本）,</span></span><br><span class="line"><span class="comment">#可以shell执行下uname -m就明白。</span></span><br><span class="line"><span class="constant">PLATFORM</span>                := <span class="variable">$(strip $(shell echo `uname -m`)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#MFLAGS将在子服务的makefile中定义,再include这个公共makefile即可</span></span><br><span class="line"><span class="comment">#如果外面没有定义，将使用uname -m得到的位数编译，这样的好处是可以指定位数编译</span></span><br><span class="line"><span class="constant">MFLAGS</span>                  := <span class="variable">$(strip $(MFLAGS)</span>)</span><br><span class="line">ifeq ($(MFLAGS),)</span><br><span class="line">ifeq ($(PLATFORM),x86_64)</span><br><span class="line">        MFLAGS          := 64</span><br><span class="line">else</span><br><span class="line">        MFLAGS          := 32</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的目标（可执行程序、静态库文件、动态库文件等）在外层makefile中定义</span></span><br><span class="line"><span class="constant">TARGET</span>                  := <span class="variable">$(strip $(TARGET)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义版本的宏，通过gcc/g++的-D参数传入，代码中就可以使用这个宏用于区分版本</span></span><br><span class="line"><span class="constant">VERSION_MAJOR</span>  := 1</span><br><span class="line"><span class="constant">VERSION_MINOR</span>  := 0</span><br><span class="line"><span class="constant">VERSION_PATCH</span>  := 0</span><br><span class="line"><span class="constant">VERSION_PATCH_MINOR</span> := 0</span><br><span class="line"><span class="constant">HAF_VERSION</span>    := <span class="variable">$(VERSION_MAJOR)</span>.<span class="variable">$(VERSION_MINOR)</span>.<span class="variable">$(VERSION_PATCH)</span>.<span class="variable">$(VERSION_PATCH_MINOR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义编译器，后面会介绍gcc和g++的使用场景</span></span><br><span class="line"><span class="constant">CC</span>              = gcc</span><br><span class="line"><span class="constant">CXX</span>             = g++</span><br><span class="line"></span><br><span class="line"><span class="comment">#首选的一些编译参数：</span></span><br><span class="line"><span class="comment">#-g: 编译出的目标文件带源文件的调试信息，用于gdb调试</span></span><br><span class="line"><span class="comment">#-fPIC: 告诉编译器产生与位置无关代码(Position-Independent Code)，则产生的代码中，</span></span><br><span class="line"><span class="comment">#       没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，</span></span><br><span class="line"><span class="comment">#       都可以正确的执行。这正是共享库.so所要求的，共享库被加载时，在内存的位置不是固定的。</span></span><br><span class="line"><span class="comment">#-Wno-deprecated: 告诉编译器不要产生deprecated的警告,那么什么是deprecated警告呢？如果代码中</span></span><br><span class="line"><span class="comment">#       使用了编译器的老特性（在未来会被抛弃的特性）时，编译产生的告警就是deprecated警告，举个例子：</span></span><br><span class="line"><span class="comment">#       一个返回值为void*类型的函数func(),g++允许这样使用(struct AA) *pt = func();这就会产生</span></span><br><span class="line"><span class="comment">#       deprecated警告，像这样的老特性还有不少，如果编译时不希望有这样的Warning，可以加上这个参数。</span></span><br><span class="line"><span class="comment">#-Wall: 打开警告开关(waring all)，-O代表默认优化，可选：-O0不优化，-O1低级优化，-O2中级优化，</span></span><br><span class="line"><span class="comment">#       -O3高级优化，-Os代码空间优化,一般这两个参数同时使用，有什么好处呢？举个很简单的例子：</span></span><br><span class="line"><span class="comment">#       int a;print a;使用没有初始化的变量时，编译优化就会产生warning了</span></span><br><span class="line"><span class="constant">CFLAGS</span>          += -g -fPIC -Wno-deprecated -Wall -O -DHAF_VERSION=\"<span class="variable">$(HAF_VERSION)</span>\"</span><br><span class="line"></span><br><span class="line"><span class="comment">#TOPDIR为工程根目录，尽量在外层makefile中以相对路径的形式定义，这样比较灵活</span></span><br><span class="line"><span class="comment">#定义根目录是为了编译时嵌入include目录，lib目录等,一般情况下这些目录就在根目录</span></span><br><span class="line"><span class="constant">INCLUDE</span>         += -I$&#123;TOPDIR&#125;/include</span><br><span class="line"><span class="constant">HAFLIB_PATH</span>     := $&#123;TOPDIR&#125;/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义编译时需包含的库文件参数，比如需要包含/AAA/lib/libBBB.a，编译参数加上 -L/AAA/lib/ -lbbb即可</span></span><br><span class="line"><span class="constant">LIB</span>             += -L$&#123;HAFLIB_PATH&#125; -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来就是提取源文件（.cpp .c等）列表，目标文件（.o文件）列表，依赖文件（.depend文件）列表了,</span></span><br><span class="line"><span class="comment">#目的是为了拼接在编译参数后面编译，比如我们熟知的gcc test.c -o test，这里会用到makefile函数：</span></span><br><span class="line"><span class="comment">#wildcard: 提取当前目录这两个后缀的文件列表</span></span><br><span class="line"><span class="comment">#sort: 按文件名排序</span></span><br><span class="line"><span class="comment">#patsubst: 替换，将上一步产生的文件列表中所有的.c替换成.o，所有的.cpp替换成.o，形成目标文件列表</span></span><br><span class="line"><span class="comment">#foreach:  makefile语法中的for循环，举个简单的例子：</span></span><br><span class="line"><span class="comment">#          names := a b c d</span></span><br><span class="line"><span class="comment">#          files := $(foreach n,$(names),$(n).o)</span></span><br><span class="line"><span class="comment">#          这样files就等于a.o b.o c.o d.o</span></span><br><span class="line"><span class="comment">#dir和nodir: 分别取/dir/和filename</span></span><br><span class="line"><span class="constant">LOCAL_SRC</span>       += <span class="variable">$(sort $(wildcard *.cpp *.c)</span>)</span><br><span class="line"><span class="constant">LOCAL_OBJ</span>       += <span class="variable">$(patsubst %.cpp,%.o, $(patsubst %.c,%.o, $(LOCAL_SRC)</span>))</span><br><span class="line"><span class="constant">DEP_FILE</span>        := <span class="variable">$(foreach obj, $(LOCAL_OBJ)</span>, <span class="variable">$(dir $(obj)</span>).<span class="variable">$(basename $(notdir $(obj)</span>)).d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#这是一个函数，用于将目标文件.a移动到根目录下的lib目录,熟悉shell编程的同学应该可以看的明白，</span></span><br><span class="line"><span class="comment">#这里就不作讲解了。</span></span><br><span class="line"><span class="constant">copyfile</span> = if test -z "<span class="variable">$(APP)</span>" || test -z "<span class="variable">$(TARGET)</span>"; then \</span><br><span class="line">               echo "['APP' or 'TARGET' option is empty.]"; exit 1; \</span><br><span class="line">            else \</span><br><span class="line">                if test ! -d $(2); then \</span><br><span class="line">                    echo "[No such dir:$(2), now we create it.]";\</span><br><span class="line">                    mkdir -p $(2);\</span><br><span class="line">                fi; \</span><br><span class="line">                echo "[Copy file $(1) -&gt; $(2)]"; \</span><br><span class="line">                cp -v $(1) $(2); \</span><br><span class="line">            fi;</span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#phony单词翻译是“假的，赝品"，顾名思义，跟在后面的都是假的目标，只是一个标识</span></span><br><span class="line"><span class="comment">#如果不加phony的话，那么就把clean当成了目标文件，紧跟其后的"："后面并没有依赖文件，</span></span><br><span class="line"><span class="comment">#就会导致每次make clean都会提示目标是最新的，无法清除文件,反之，如果我们加上了,这次额标识</span></span><br><span class="line"><span class="comment">#就不会当成目标文件，也就可以清除文件了。</span></span><br><span class="line"><span class="phony"><span class="keyword">.PHONY</span>: all clean release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为什么makefile里面都会有一个all呢？因为默认执行make命令的时候，其实就是make all。</span></span><br><span class="line"><span class="comment">#all后面所有的依赖文件以及 依赖文件所依赖的文件 都会按照顺序递归生成</span></span><br><span class="line">all : </span><br><span class="line">    $(LOCAL_OBJ) $(DEP_FILE) $(TARGET)</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter函数：顾名思义就是过滤了，将TARGET里的.a文件过滤出来单独生成，因为普通的可执行文件和.a以及.so等</span></span><br><span class="line"><span class="comment">#生成方式都会不同，所以要单独处理。</span></span><br><span class="line"><span class="comment">#ar是将.o文件链接生成静态库的命令。</span></span><br><span class="line"><span class="comment">#$@是本次目标生成动作中所有的目标文件，对应的$^是所有依赖文件，$&lt;是第一个依赖文件</span></span><br><span class="line">$(filter %.a,$(TARGET)) : $(LOCAL_OBJ)</span><br><span class="line">    ar r $@ $(LOCAL_OBJ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-shared是生成共享库.so必须参数，如果指定了这个参数，一定要加上-fPIC，原因前面已讲述</span></span><br><span class="line"><span class="comment">#.so的链接我们一般采用gcc的链接器来完成</span></span><br><span class="line">$(filter %.so,$(TARGET)) : $(LOCAL_OBJ)</span><br><span class="line">    $(CC) -m$(MFLAGS) -shared -o $@ $(LOCAL_OBJ) $(LIB)</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面讲了filter，对应filter-out的意思就呼之欲出了：过滤之后剩下的文件</span></span><br><span class="line"><span class="comment">#这里一般对应普通的可执行文件的编译</span></span><br><span class="line">$(filter-out %.so %.a,$(TARGET)) : $(LOCAL_OBJ)</span><br><span class="line">    $(CXX) -m$(MFLAGS) $(CFLAGS) -o $@ $^ $(INCLUDE) $(LIB)</span><br><span class="line"></span><br><span class="line"><span class="title">clean:</span></span><br><span class="line">    rm -vf $(LOCAL_OBJ) $(TARGET) $(DEP_FILE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#call调用makefile自定义函数copyfile</span></span><br><span class="line"><span class="title">release:</span></span><br><span class="line">    @$(call copyfile, *.a, $(HAFLIB_PATH))</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌入依赖文件，大家打开依赖文件都可以看出来,里面是每个目标文件的所有依赖文件列表</span></span><br><span class="line"><span class="comment">#后面会讲到.d文件的生成方法，这里先说下为什么要生成并嵌入.d文件：</span></span><br><span class="line"><span class="comment">#C源码的开头经常有一系列被包含的头文件，例如 stdio.h。</span></span><br><span class="line"><span class="comment">##include &lt;stdio.h&gt;#include "foo.h"int main(....)</span></span><br><span class="line"><span class="comment">#如果你的 foo.h 被改变之后，要确保这个文件也会被重新编译，就要在你的 Makefile 这样写：</span></span><br><span class="line"><span class="comment">#foo: foo.c foo.h</span></span><br><span class="line"><span class="comment">#当你的项目变得越来越大，你自己的头文件越来越多的时候，要追踪所有这些头文件和所有依赖它的</span></span><br><span class="line"><span class="comment">#文件会是一件痛苦的事情。如果你改变了其中一个头文件，却忘了重新编译所有依赖它的源文件，结果会让我们失望。</span></span><br><span class="line"><span class="comment">#这个时候就需要用到.d文件了，该文件里列出来所有源文件需要包含的头文件，并按照makefile的语法组成依赖关系，</span></span><br><span class="line"><span class="comment">#这样我们嵌入进来之后，就可以达到“foo: foo.c foo.h”这样的目的了。</span></span><br><span class="line">ifneq ($(DEP_FILE),)</span><br><span class="line">-include $(DEP_FILE)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里即是生成依赖文件.depend文件：</span></span><br><span class="line"><span class="comment">#gcc -MM即是生成依赖关系文件的方式</span></span><br><span class="line"><span class="comment">#第三行就是gcc -MM test.cpp将生成的“test.o: test.cpp ../../include/test.h“写入.test.d中。</span></span><br><span class="line">.%.d: %.cpp %.c</span><br><span class="line">    @echo "update $@ ..."; \</span><br><span class="line">    $(CC) $(INCLUDE) -MM $&lt; &gt;&gt; $@;</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面编译cpp和c文件分别用g++和gcc编译</span></span><br><span class="line"><span class="comment">#注意：加-c选项是告诉编译器，只编译成指定的.o文件即可，不需要链接</span></span><br><span class="line">%.o: %.cpp</span><br><span class="line">    $(CXX) -m$(MFLAGS) $(CFLAGS) $(INCLUDE) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -m$(MFLAGS) $(CFLAGS) $(INCLUDE) -o $@ -c $&lt;</span><br></pre></td></tr></table></figure>
<h2 id="子服务Makefile">子服务Makefile</h2><p>上面讲完公共makefile之后，这里将附上子服务的makefile，看是如何引用公共makefile的，<br>这样分开之后的好处不言而喻，每增加一个子服务只需要在外层makefile定义一些独有的变量即可：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include相当于把公共makefile拷贝一份放到这里，先定义这些变量再include公共makefile，</span></span><br><span class="line"><span class="comment">#定制子服务独有的makefile</span></span><br><span class="line"><span class="constant">APP</span>            := LEARNING</span><br><span class="line"><span class="constant">TOPDIR</span>         := ../..</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译要用的静态库</span></span><br><span class="line"><span class="constant">INCLUDE</span> +=</span><br><span class="line"><span class="constant">LIB</span>     += -lutil</span><br><span class="line"></span><br><span class="line"><span class="constant">TARGET</span> := test</span><br><span class="line"></span><br><span class="line">include $&#123;TOPDIR&#125;/makefile</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转载本站文章请注明作者和出处_码畔-coderpan，请勿用于任何商业用途">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转载本站文章请注明作者和出处 <strong>码畔-coderpan</strong>，请勿用于任何商业用途</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简明Vim练级攻略]]></title>
      <url>http://coderpan.github.io/2015/11/15/%E7%AE%80%E6%98%8EVim%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。<br><a href="http://www.vim.org/" target="_blank" rel="external">Vim</a> the Six Billion Dollar editor</p>
<blockquote>
<p class="text-info">Better, Stronger, Faster.</p>
</blockquote>
<p>学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p>
<p>我建议下面这四个步骤：</p>
<ol>
<li>存活</li>
<li>感觉良好</li>
<li>觉得更好，更强，更快</li>
<li>使用VIM的超能力</li>
</ol>
<p>当你走完这篇文章，你会成为一个vim的 superstar。</p>
<a id="more"></a>
<p>在开始学习以前，我需要给你一些警告：</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间。</li>
<li>需要不断地练习，就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上，你需要2周时间的苦练，而不是3天。</li>
</ul>
<h2 id="第一级：存活">第一级：存活</h2><ol>
<li>安装 vim</li>
<li>启动 vim</li>
<li>什么也别干！请先阅读</li>
</ol>
<p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<ul>
<li>启动Vim后，vim在 <em>Normal</em> 模式下。</li>
<li>让我们进入 <em>Insert</em> 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li>
<li>此时，你可以输入文本了，就像你用“记事本”一样。</li>
<li>如果你想返回 <em>Normal</em> 模式，请按 ESC 键。</li>
</ul>
<p>现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：</p>
<blockquote>
<ul>
<li>i → Insert 模式，按 ESC 回到 Normal 模式.</li>
<li>x → 删当前光标所在的一个字符。</li>
<li>:wq → 存盘 + 退出 (:w 存盘, :q 退出)   （陈皓注：:w 后可以跟文件名）</li>
<li>dd → 删除当前行，并把删除的行存到剪贴板里</li>
<li>p → 粘贴剪贴板</li>
<li>hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</li>
<li>:help <command> → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q）</li>
</ul>
</blockquote>
<p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>但是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了。</strong> 这个你需要知道。</p>
<p>标记:</p>
<ul>
<li>下面的文字中，如果是 Ctrl-λ我会写成 <c-λ>.</c-λ></li>
<li>以 : 开始的命令你需要输入 <enter>回车，例如 — 如果我写成 :q 也就是说你要输入 :q<enter>.</enter></enter></li>
</ul>
<h2 id="第二级：感觉良好">第二级：感觉良好</h2><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p>
<ol>
<li><p>各种插入模式</p>
<blockquote>
<ul>
<li>a → 在光标后插入</li>
<li>o → 在当前行后插入一个新行</li>
<li>O → 在当前行前插入一个新行</li>
<li>cw → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
</blockquote>
</li>
<li><p>简单的移动光标</p>
<blockquote>
<ul>
<li>0 → 数字零，到行头</li>
<li>^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li>
<li>$ → 到本行行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>/pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</li>
</ul>
</blockquote>
</li>
<li><p>拷贝/粘贴 （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</p>
<blockquote>
<ul>
<li>P → 粘贴</li>
<li>yy → 拷贝当前行当行于 ddP</li>
</ul>
</blockquote>
</li>
<li><p>Undo/Redo</p>
<blockquote>
<ul>
<li>u → undo</li>
<li><c-r> → redo</c-r></li>
</ul>
</blockquote>
</li>
<li><p>打开/保存/退出/改变文件(Buffer)</p>
<blockquote>
<ul>
<li>:e <path to="" file=""></path> → 打开一个文件</li>
<li>:w → 存盘</li>
<li>:saveas <path to="" file=""></path> → 另存为 <path to="" file=""></path></li>
<li>:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li>
<li>:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。</li>
<li>:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li>
</ul>
</blockquote>
</li>
</ol>
<p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h2 id="第三级:_更好，更强，更快">第三级: 更好，更强，更快</h2><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h4 id="更好">更好</h4><p>下面，让我们看一下vim是怎么重复自己的：</p>
<ol>
<li>. → (小数点) 可以重复上一次的命令</li>
<li>N<command> → 重复某个命令N次</li>
</ol>
<p>下面是一个示例，找开一个文件你可以试试下面的命令：</p>
<blockquote>
<ul>
<li>2dd → 删除2行</li>
<li>3p → 粘贴文本3次</li>
<li>100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</li>
<li>. → 重复上一个命令—— 100 “desu “.</li>
<li><ol>
<li>→ 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="更强">更强</h4><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong></p>
<ol>
<li>NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</li>
<li>gg → 到第一行。（陈皓注：相当于1G，或 :1）</li>
<li>G → 到最后一行。</li>
<li>按单词移动：<blockquote>
<ol>
<li>w → 到下一个单词的开头。</li>
<li>e → 到下一个单词的结尾。<br><br> </li>
</ol>
<p>如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）</p>
<p align="left"> 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）<img src="word_moves.jpg" alt=""> </p> 


</blockquote>
</li>
</ol>
<p>下面，让我来说说最强的光标移动：</p>
<blockquote>
<ul>
<li>% : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上）</li>
<li>* 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li>
</ul>
</blockquote>
<p>相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h4 id="更快">更快</h4><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p>
<p>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</p>
<p>例如 0y$ 命令意味着：</p>
<ul>
<li>0 → 先到行头</li>
<li>y → 从这里开始拷贝</li>
<li>$ → 拷贝到本行最后一个字符</li>
</ul>
<p>你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<ul>
<li>d (删除 )</li>
<li>v (可视化的选择)</li>
<li>gU (变大写)</li>
<li>gu (变小写)</li>
<li>等等</li>
</ul>
<p>（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</p>
<h2 id="第四级_–_Vim_超能力">第四级 – Vim 超能力</h2><p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<p><strong> 在当前行上移动光标: 0 ^ $ f F t T , ; </strong></p>
<blockquote>
<ul>
<li>0 → 到行头</li>
<li>^ → 到本行的第一个非blank字符</li>
<li>$ → 到行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</li>
<li>t, → 到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li>3fa → 在当前行查找第三个出现的a。</li>
<li>F 和 T → 和 f 和 t 一样，只不过是相反方向。<br><img src="line_moves.jpg" alt=""></li>
</ul>
</blockquote>
<p>还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。</p>
<p><strong> 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt; </strong></p>
<p>在visual 模式下，这些命令很强大，其命令格式为</p>
<p>&lt;action&gt;a&lt;object&gt; 和 &lt;action&gt;i&lt;object&gt;</p>
<ul>
<li>action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。</li>
<li>object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。</li>
</ul>
<p>假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。</p>
<blockquote>
<ul>
<li>vi” → 会选择 foo.</li>
<li>va” → 会选择 “foo”.</li>
<li>vi) → 会选择 “foo”.</li>
<li>va) → 会选择(“foo”).</li>
<li>v2i) → 会选择 map (+) (“foo”)</li>
<li>v2a) → 会选择 (map (+) (“foo”))</li>
</ul>
</blockquote>
<p><img src="textobjects.png" alt=""></p>
<p><strong> 块操作: &lt;C-v&gt; </strong></p>
<p>块操作，典型的操作： <code> 0 &lt;C-v&gt; &lt;C-d&gt; I- - [ESC] </code></p>
<ul>
<li>^ → 到行头</li>
<li><c-v> → 开始块操作</c-v></li>
<li><c-d> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</c-d></li>
<li>I- - [ESC] → I是插入，插入“- -”，按ESC键来为每一行生效。</li>
</ul>
<p><img src="rectangular-blocks.gif" alt=""></p>
<p>在Windows下的vim，你需要使用 <c-q> 而不是 <c-v> ，<c-v> 是拷贝剪贴板。</c-v></c-v></c-q></p>
<p><strong> 自动提示： <code> &lt;C-n&gt; 和 &lt;C-p&gt; </code>  </strong></p>
<p>在 Insert 模式下，你可以输入一个词的开头，然后按 <c-p>或是<c-n>，自动补齐功能就出现了……</c-n></c-p></p>
<p><img src="completion.gif" alt=""></p>
<p><strong> 宏录制： qa 操作序列 q, @a, @@ </strong></p>
<ul>
<li>qa 把你的操作记录在寄存器 a。</li>
<li>于是 @a 会replay被录制的宏。</li>
<li>@@ 是一个快捷键用来replay最新录制的宏。</li>
</ul>
<blockquote>
<p><strong><em>示例</em></strong></p>
<p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p>
<ul>
<li>qaYp<c-a>q→<ul>
<li>qa 开始录制</li>
<li>Yp 复制行.</li>
<li><c-a> 增加1.</c-a></li>
<li>q 停止录制.</li>
</ul>
</c-a></li>
<li>@a → 在1下面写下 2</li>
<li>@@ → 在2 正面写下3</li>
<li>现在做 100@@ 会创建新的100行，并把数据增加到 103.<br><img src="macros.gif" alt=""></li>
</ul>
</blockquote>
<p><strong> 可视化选择： <code>v,V,&lt;C-v&gt;</code> </strong><br>前面，我们看到了 <c-v>的示例 （在Windows下应该是<c-q>），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：</c-q></c-v></p>
<ul>
<li>J → 把所有的行连接起来（变成一行）</li>
<li>&lt; 或 &gt; → 左右缩进</li>
<li>= → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）<br><img src="autoindent.gif" alt=""></li>
</ul>
<p>在所有被选择的行后加上点东西：</p>
<ul>
<li>&lt;C-v&gt;</li>
<li>选中相关的行 (可使用 j 或 <c-d> 或是 /pattern 或是 % 等……)</c-d></li>
<li>$ 到行最后</li>
<li>A, 输入字符串，按 ESC。<br><img src="append-to-many-lines.gif" alt=""></li>
</ul>
<p><strong> 分屏: :split 和 vsplit. </strong></p>
<p>下面是主要的命令，你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。</p>
<blockquote>
<ul>
<li>:split → 创建分屏 (:vsplit创建垂直分屏)</li>
<li>&lt;C-w&gt;&lt;dir&gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。</li>
<li>&lt;C-w&gt;_ (或 &lt;C-w&gt;|) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏)</li>
<li>&lt;C-w&gt;+ (或 &lt;C-w&gt;-) : 增加尺寸</li>
</ul>
</blockquote>
<p><img src="split.gif" alt=""></p>
<h2 id="结束语">结束语</h2><ul>
<li><p>上面是作者最常用的90%的命令。</p>
</li>
<li><p>我建议你每天都学1到2个新的命令。</p>
</li>
<li><p>在两到三周后，你会感到vim的强大的。</p>
</li>
<li><p>有时候，学习VIM就像是在死背一些东西。</p>
</li>
<li><p>幸运的是，vim有很多很不错的工具和优秀的文档。</p>
</li>
<li><p>运行vimtutor直到你熟悉了那些基本命令。</p>
</li>
<li><p>其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt.</p>
</li>
<li><p>你会学习到诸如  !， 目录，寄存器，插件等很多其它的功能。</p>
</li>
<li><p>学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
</li>
</ul>
<p><br></p>
<p align="center">——————————正文结束——————————</p>

<p>本文转自酷壳：<a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="external">http://coolshell.cn/articles/5426.html</a></p>
]]></content>
    </entry>
    
  
  
</search>
